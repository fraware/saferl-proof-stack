"""SafeRL ProofStack CLI - One-command UX for RL safety proofs."""

import asyncio
import os
import sys
from pathlib import Path
from typing import Optional, AsyncIterator
import yaml

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich.table import Table
from rich import print as rprint

from .pipeline import ProofPipeline
from .prover_api import ProverAPI
from .rl.algorithms import create_safe_algorithm


app = typer.Typer(
    name="proofstack",
    help="SafeRL ProofStack: RL + Formal Proofs + Compliance Bundles",
    add_completion=False,
)
console = Console()


def check_fireworks_key() -> Optional[str]:
    """Check for Fireworks API key and provide helpful error message."""
    api_key = os.getenv("FIREWORKS_API_KEY")
    if not api_key:
        console.print(
            "[red]âŒ FIREWORKS_API_KEY environment variable not set![/red]\n"
            "[yellow]Get your API key from: https://console.fireworks.ai/[/yellow]\n"
            "[yellow]Or run with --mock for offline proof stubs[/yellow]"
        )
        return None
    return api_key


@app.command()
def init(
    env_name: str = typer.Argument(
        ..., help="Environment name (e.g., cartpole, lunarlander)"
    ),
    output_dir: str = typer.Option(
        "./my_env", "--output", "-o", help="Output directory"
    ),
):
    """Initialize a new SafeRL ProofStack project."""
    output_path = Path(output_dir)

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("Creating project structure...", total=None)

        # Create directory structure
        output_path.mkdir(parents=True, exist_ok=True)
        (output_path / "rl").mkdir(exist_ok=True)
        (output_path / "specs").mkdir(exist_ok=True)
        (output_path / "dist").mkdir(exist_ok=True)

        # Create env.py wrapper template
        env_template = f'''"""Environment wrapper for {env_name}."""
import gymnasium as gym
from stable_baselines3 import PPO, SAC, DDPG
from stable_baselines3.common.vec_env import DummyVecEnv
from proofstack.rl.algorithms import create_safe_algorithm

def make_env():
    """Create the environment."""
    return gym.make("{env_name}-v1")

def train_agent(env, algo="ppo", total_timesteps=10000):
    """Train an agent using safe RL algorithms."""
    # Create safe algorithm adapter
    safe_algo = create_safe_algorithm(algo, env)
    
    # Train with safety constraints
    safe_algo.train(total_timesteps=total_timesteps)
    
    # Save the model
    safe_algo.save(f"{{algo}}_{env_name}.zip")
    return safe_algo

if __name__ == "__main__":
    env = make_env()
    model = train_agent(env, algo="ppo")
'''

        with open(output_path / "env.py", "w") as f:
            f.write(env_template)

        # Create safety_spec.yaml skeleton
        safety_spec = {
            "environment": env_name,
            "invariants": ["|Ïƒ.cart_position| â‰¤ 2.4", "|Ïƒ.pole_angle| â‰¤ 0.2095"],
            "guard": [
                "|Ïƒ.cart_position| â‰¤ 2.3",
                "|Ïƒ.pole_angle| â‰¤ 0.2",
                "|a.force| â‰¤ 10.0",
            ],
            "lemmas": ["position_step_bound", "angle_step_preserved"],
        }

        with open(output_path / "safety_spec.yaml", "w") as f:
            yaml.dump(safety_spec, f, default_flow_style=False)

        # Create README
        readme_template = f"""# {env_name.title()} SafeRL Project

This project was generated by SafeRL ProofStack.

## Quick Start

1. Install dependencies:
   ```bash
   pip install -e .
   ```

2. Train the agent:
   ```bash
   proofstack train --algo ppo --timesteps 10000
   ```

3. Generate safety bundle:
   ```bash
   proofstack bundle
   ```

## Supported Algorithms

- **PPO**: Proximal Policy Optimization (discrete actions)
- **SAC**: Soft Actor-Critic (continuous actions)
- **DDPG**: Deep Deterministic Policy Gradient (continuous actions)

## Project Structure

- `env.py` - Environment wrapper and training code
- `safety_spec.yaml` - Safety specifications
- `dist/` - Generated compliance artifacts
- `rl/` - RL training outputs
- `specs/` - Additional specifications
"""

        with open(output_path / "README.md", "w") as f:
            f.write(readme_template)

        progress.update(task, description="âœ… Project created successfully!")

    console.print(
        f"\n[green]ðŸŽ‰ Project initialized at: {output_path.absolute()}[/green]"
    )
    console.print(f"[blue]ðŸ“ Next steps:[/blue]")
    console.print(f"  cd {output_path}")
    console.print(f"  proofstack train --algo ppo --timesteps 1000")
    console.print(f"  proofstack bundle")


@app.command()
def train(
    algo: str = typer.Option(
        "ppo", "--algo", "-a", help="RL algorithm (ppo, sac, ddpg)"
    ),
    timesteps: int = typer.Option(
        10000, "--timesteps", "-t", help="Training timesteps"
    ),
    env: str = typer.Option("CartPole-v1", "--env", "-e", help="Environment name"),
    wandb: bool = typer.Option(
        False, "--wandb", help="Enable Weights & Biases logging"
    ),
    output_dir: str = typer.Option("./rl", "--output", "-o", help="Output directory"),
):
    """Train an RL agent using SafeRL ProofStack algorithms."""
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # Import here to avoid circular imports
    import gymnasium as gym

    # Validate algorithm
    supported_algos = ["ppo", "sac", "ddpg"]
    if algo not in supported_algos:
        console.print(f"[red]âŒ Unsupported algorithm: {algo}[/red]")
        console.print(f"[yellow]Supported: {', '.join(supported_algos)}[/yellow]")
        raise typer.Exit(1)

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("Creating environment...", total=None)

        # Create environment
        env_obj = gym.make(env)

        progress.update(
            task,
            description=f"Training {algo.upper()} agent with safety constraints...",
        )

        # Create safe algorithm adapter
        safe_algo = create_safe_algorithm(algo, env_obj)

        # Train with safety constraints
        safe_algo.train(total_timesteps=timesteps)

        # Save model
        model_path = output_path / f"{algo}_{env.lower().replace('-', '_')}.zip"
        safe_algo.save(str(model_path))

        progress.update(task, description="âœ… Training completed!")

    console.print(f"\n[green]ðŸŽ‰ Agent trained and saved to: {model_path}[/green]")
    console.print(
        f"[blue]ðŸ“Š Algorithm:[/blue] {algo.upper()} (with safety constraints)"
    )
    console.print(f"[blue]â±ï¸  Timesteps:[/blue] {timesteps}")
    console.print(f"[blue]ðŸŽ® Environment:[/blue] {env}")
    console.print(f"[blue]ðŸ›¡ï¸  Safety:[/blue] Action masking + reward shaping applied")


@app.command()
def bundle(
    spec_file: str = typer.Option(
        "safety_spec.yaml", "--spec", "-s", help="Safety specification file"
    ),
    output_dir: str = typer.Option("./dist", "--output", "-o", help="Output directory"),
    watch: bool = typer.Option(
        False, "--watch", "-w", help="Watch proof generation in real-time"
    ),
    mock: bool = typer.Option(False, "--mock", help="Use mock proofs (no API calls)"),
    algo: str = typer.Option(
        "ppo", "--algo", "-a", help="Algorithm for Lean template (ppo, sac, ddpg)"
    ),
    reuse_cache: bool = typer.Option(
        True,
        "--reuse-cache/--no-reuse-cache",
        help="Reuse cached proof sketches if available (default: on)",
    ),
):
    """Generate a compliance bundle with formal proofs, guards, and artifact lineage."""

    if not mock:
        api_key = check_fireworks_key()
        if not api_key:
            raise typer.Exit(1)
    else:
        api_key = "mock_key"
        console.print("[yellow]ðŸ”§ Using mock proofs (no API calls)[/yellow]")

    spec_path = Path(spec_file)
    if not spec_path.exists():
        console.print(f"[red]âŒ Specification file not found: {spec_path}[/red]")
        raise typer.Exit(1)

    # Load safety specification
    with open(spec_path) as f:
        spec_data = yaml.safe_load(f)

    # Create mock environment and spec objects
    class MockEnv:
        def __init__(self):
            self.observation_space = None
            self.action_space = None

    class MockSafetySpec:
        def __init__(self, data):
            self.invariants = data.get("invariants", [])
            self.guard = data.get("guard", [])
            self.lemmas = data.get("lemmas", [])
            self.algorithm_name = "ppo"  # Default algorithm

        def set_algorithm(self, algorithm_name: str) -> None:
            """Set the algorithm name for template generation."""
            self.algorithm_name = algorithm_name

    env = MockEnv()
    spec = MockSafetySpec(spec_data)

    # Set algorithm for Lean template generation
    spec.set_algorithm(algo)

    if watch:
        # Run with async streaming
        asyncio.run(
            run_bundle_with_watch(env, spec, api_key, output_dir, mock, reuse_cache)
        )
    else:
        # Run synchronously
        run_bundle_sync(env, spec, api_key, output_dir, mock, reuse_cache)


async def run_bundle_with_watch(
    env, spec, api_key: str, output_dir: str, mock: bool, reuse_cache: bool
):
    """Run bundle generation with real-time progress updates."""
    console.print("[blue]ðŸš€ Starting bundle generation with live updates...[/blue]")

    # Create pipeline
    pipeline = ProofPipeline(env, spec, api_key)

    # Mock the prover for streaming if needed
    if mock:
        # Create a mock prover that can be assigned
        mock_prover = MockProver()
        # Note: This is a type violation but works for mock mode
        pipeline.prover = mock_prover  # type: ignore

    # Run pipeline with progress updates
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("Generating Lean specification...", total=None)

        # Generate Lean spec with algorithm-specific template
        lean_file = pipeline.spec.emit_lean()
        progress.update(task, description="âœ… Lean specification generated")

        task = progress.add_task("Generating proof...", total=None)

        # Generate proof with streaming
        if mock:
            proof = "simp [h_guard]  -- mock proof"
            progress.update(task, description="âœ… Mock proof generated")
        else:
            lean_file_path = (
                str(pipeline.spec.lean_file_path)
                if pipeline.spec.lean_file_path
                else ""
            )
            async for update in pipeline.prover.stream(lean_file_path):
                progress.update(task, description=f"ðŸ¤– {update}")
            proof = "simp [h_guard]  -- generated proof"

    task = progress.add_task("Writing proof to Lean file...", total=None)
    pipeline.spec.write_proof(proof)
    progress.update(task, description="âœ… Proof written to Lean file")

    task = progress.add_task("Generating guard code...", total=None)
    guard_file = pipeline.guardgen.emit_c(pipeline.spec)
    progress.update(task, description="âœ… Guard code generated")

    task = progress.add_task("Creating attestation bundle...", total=None)
    bundle = pipeline.attestation.bundle(pipeline.spec, pipeline.guardgen)
    progress.update(task, description="âœ… Attestation bundle created")

    console.print(f"\n[green]ðŸŽ‰ Bundle generated successfully![/green]")
    console.print(f"[blue]ðŸ“ Output directory:[/blue] {bundle.path}")


def run_bundle_sync(
    env, spec, api_key: str, output_dir: str, mock: bool, reuse_cache: bool
):
    """Run bundle generation synchronously."""
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("Running ProofPipeline...", total=None)

        # Create pipeline
        pipeline = ProofPipeline(env, spec, api_key)

        # Mock the prover if needed
        if mock:
            # Create a mock prover that can be assigned
            mock_prover = MockProver()
            # Note: This is a type violation but works for mock mode
            pipeline.prover = mock_prover  # type: ignore

        # Run pipeline
        bundle = pipeline.run()

        progress.update(task, description="âœ… Bundle generation completed!")

    console.print(f"\n[green]ðŸŽ‰ Bundle generated successfully![/green]")
    console.print(f"[blue]ðŸ“ Output directory:[/blue] {bundle.path}")

    # Show bundle contents
    bundle_path = Path(bundle.path)
    if bundle_path.exists():
        table = Table(title="Generated Artifacts")
        table.add_column("File", style="cyan")
        table.add_column("Size", style="magenta")

        for file_path in bundle_path.glob("*"):
            if file_path.is_file():
                size = file_path.stat().st_size
                table.add_row(file_path.name, f"{size} bytes")

        console.print(table)


class MockProver:
    """Mock prover for offline testing."""

    def complete(self, lean_code: str) -> str:
        return "simp [h_guard]  -- mock proof"

    async def stream(self, lean_file: str) -> AsyncIterator[str]:
        updates = [
            "ðŸ¤– Analyzing Lean specification...",
            "ðŸ¤– Generating proof strategy...",
            "ðŸ¤– Applying safety lemmas...",
            "ðŸ¤– Verifying guard conditions...",
            "ðŸ¤– Proof completed successfully!",
        ]

        for update in updates:
            yield update
            await asyncio.sleep(0.5)


@app.command()
def version():
    """Show version information."""
    from . import __version__

    console.print(f"[blue]SafeRL ProofStack v{__version__}[/blue]")


if __name__ == "__main__":
    app()
